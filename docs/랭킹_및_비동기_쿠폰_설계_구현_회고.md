## 보고서: 판매 랭킹(Redis)과 비동기 선착순 쿠폰 발급 설계·구현·회고

### 판매 랭킹 시스템 (Sales Ranking)

#### 요구사항 요약
- 판매량 기준 Top-N 조회(기본 10)
- Redis 1차 조회, 비어있으면 DB에서 로딩 후 재시도
- 효율적 조회(reverseRangeWithScores), 점수(null) 안전 처리
- TTL 정책: 24시간(일 단위)

#### 설계
- 자료구조: Redis Sorted Set
    - Key: `product:sales:ranking`
    - Member: `productId`(String), Score: `salesCount`(Double)
- 핵심 로직 (ProductService)
    - `incrementSalesRanking(productId, quantity)`: 판매 발생 시 점수 증가(Null 안전)
    - `getTopProductsFromRedis(limit)`: ZSET에서 Top-N을 `reverseRangeWithScores`로 조회, 비면 `loadProductsToRedis()` 수행 후 재조회
    - `loadProductsToRedis()`: DB의 전체 판매량(`findProductsBySales()`)을 Redis ZSET으로 로드
- DB 접근 단순화: `findProductsBySales()`를 `List<ProductSalesCountEntity>`로 타입 안전화
- TTL: `RedisCacheConfig`에서 기본 24시간(인기상품 캐시 등과 일관)


---

### 비동기 선착순 쿠폰 발급

#### 요구사항 요약
- “먼저 요청한 사용자부터” 순서대로 처리(FIFO)
- 대기열은 항상 잔여 재고만큼만 허용 → 큐 진입 = 발급 확정
- 사용자에게는 즉시 응답, 실제 발급/DB 반영은 비동기
- 중복 발급 방지

#### 설계
- 자료구조: Redis List + Sorted Set
    - Queue(List): `coupon:queue:{couponId}` — RPUSH(등록), LPOP(소비)로 FIFO
    - Order(Sorted Set): `coupon:order:{couponId}` — 발급 완료 순서 기록(타임스탬프)
- 흐름 (CouponService)
    1) 동기 진입: `issueCoupon(userId, couponId)`
        - `findById` → `coupon.canIssue()` → 중복 발급 검사
        - 잔여 재고 계산 후 `queueSize >= remaining`이면 즉시 “선착순 마감”
        - RPUSH로 큐에 등록, 즉시 응답(`status = ISSUED`)
        - `processQueueAsync(couponId)`로 비동기 트리거
    2) 비동기 소비: `processQueueAsync` → `processQueue`
        - LPOP으로 FIFO 소비
        - `issueOneReserved(userId, couponId)` 트랜잭션에서 사용자 쿠폰 생성 + `issuedCount` 증가(원자적)
        - 성공 시 `coupon:order:{couponId}`에 순서 기록
        - 실패 시 큐 끝에 재삽입(재시도) → 큐 진입 사용자는 발급 보장

---

### 회고

- 랭킹: Redis ZSET 기반 Top-N, DB fallback, 24h TTL, null 안전 갱신
- 쿠폰: Redis List 기반 FIFO 큐, 잔여 재고만 큐 진입, 큐 진입 즉시 “ISSUED”, 비동기 트랜잭션/재시도
---