## 트랜잭션 분리 및 이벤트 기반 관심사 분리 설계 문서

### 1) 범위
- 결제 완료 후 실시간 데이터 플랫폼 전송 로직을 핵심 트랜잭션에서 분리
- 도메인 분리(어플리케이션/DB 분리) 시 발생할 수 있는 트랜잭션 처리 한계와 대응

### 2) 현재 구조 요약
- 결제 처리: `PaymentService.processPayment`
- 주문 검증/금액 확정 → 재고 차감 → 잔액 차감 → 쿠폰 사용 → 결제 저장 → 주문 완료
- 이벤트 분리: 결제 트랜잭션 커밋 후 `paymentId(Long)` 이벤트 발행
- `PaymentEventListener`가 비동기로 DB 재조회 → Mock 데이터 플랫폼 전송(콘솔 로그)

### 3) 도메인 분리 시 트랜잭션 한계
- 다중 도메인/DB 분리 시 단일 트랜잭션으로 일관성 보장 어려움
- 예: 재고 차감 성공, 결제 저장 실패 → 부분 완료 위험
- 외부 연동(데이터 플랫폼 전송)이 동기/동일 트랜잭션에 섞이면 커밋 지연/장애 전파

### 4) 해결 전략
- 트랜잭션 범위 축소: 핵심 트랜잭션은 “주문/재고/잔액/쿠폰/결제”까지만. 외부 연동 제외
- 커밋 후 이벤트 발행 → 리스너에서 비동기 처리
- 이벤트 기반 관심사 분리
  - 발행: `ApplicationEventPublisher.publishEvent(paymentId)`
  - 구독: `@TransactionalEventListener(AFTER_COMMIT)` + `@Async`
  - 전송 실패는 본 트랜잭션에 영향 없음(격리)
- 운영 단순화: Mock 전송으로 최소 구현. 추후 실제 HTTP 호출로 대체 가능

### 5) 이벤트 목록 및 흐름
- `PaymentCompleted(paymentId: Long)`
  - 발행자: `PaymentService` (결제 저장/주문완료 후)
  - 구독자: `PaymentEventListener`
  - 처리: `paymentRepository.findById(paymentId)` 재조회 → Mock 전송

### 6) 트랜잭션 경계
- Service 트랜잭션(동기): DB 일관성 보장
- 이벤트 처리(비동기): 커밋 이후 실행, 독립 실패/재시도 로직 확장 가능
