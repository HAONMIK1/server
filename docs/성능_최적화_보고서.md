# 🚀 성능 최적화 보고서

## 📋 테스트 환경
- **데이터베이스**: MySQL 9.3.0
- **테스트 데이터**: 4,868,278개 상품
- **측정 항목**: 인기상품 TOP 5 조회 쿼리

---

## 🔍 핵심 병목 쿼리 분석

### 1. 인기상품 조회 쿼리 (Critical)
```sql
SELECT p.id, ps.sales_count, pv.view_count, p.reg_dt
FROM product p 
INNER JOIN product_sales_count ps ON p.id = ps.product_id 
INNER JOIN product_view_count pv ON p.id = pv.product_id 
ORDER BY ps.sales_count DESC, pv.view_count DESC, p.reg_dt DESC 
LIMIT 5;
```

**현재 성능**: 16.7초 (4.8M 상품 기준)  
**병목 원인**:
- 3개 테이블 대용량 JOIN
- 복합 정렬 조건으로 인한 임시 테이블 생성

---

## 📊 실제 성능 테스트 결과

### 1. 최적화 시도별 성능 비교

| 최적화 방법 | 실행 시간 | 성능 변화 | 비고 |
|-------------|-----------|-----------|------|
| **기본 쿼리** (LEFT JOIN + COALESCE) | **16.798초** | 기준점 | 인덱스 없음 |
| **1차 인덱스 추가** | **17.975초** | 🔴 **-7.0%** | **성능 악화!** |
| 인덱스 제거 후 | 16.705초 | ⚫ ±0% | 원상복구 |
| **최적화된 인덱스** | **13.382초** | 🟢 **+20.3%** | **최고 성능** |

### 2. 인덱스 시행착오 과정

#### ❌ 1차 시도 - 실패한 인덱스들 (성능 악화)
```sql
-- 복합 인덱스 과도하게 생성
CREATE INDEX idx_product_sales_count_product_id ON product_sales_count(product_id);
CREATE INDEX idx_product_sales_count_sales_desc ON product_sales_count(sales_count DESC);
CREATE INDEX idx_product_view_count_product_id ON product_view_count(product_id);
CREATE INDEX idx_product_view_count_view_desc ON product_view_count(view_count DESC);
CREATE INDEX idx_product_reg_dt_desc ON product(reg_dt DESC);
CREATE INDEX idx_sales_count_view_count ON product_sales_count(sales_count DESC, product_id);
CREATE INDEX idx_view_count_sales_count ON product_view_count(view_count DESC, product_id);

-- 결과: 16.798초 → 17.975초 (7% 성능 저하)
```

**실패 원인 분석:**
- **과도한 인덱스**: 7개 인덱스 동시 생성으로 옵티마이저 혼란
- **복합 인덱스 오남용**: 실제 쿼리 패턴과 맞지 않음
- **인덱스 유지비용**: 대용량 데이터에서 인덱스 유지 오버헤드

#### ✅ 2차 시도 - 성공한 최적 인덱스
```sql
-- 핵심 정렬 조건에만 집중
CREATE INDEX idx_sales_count_desc ON product_sales_count(sales_count DESC);
CREATE INDEX idx_view_count_desc ON product_view_count(view_count DESC);

-- 결과: 16.705초 → 13.382초 (20% 성능 향상)
```

**성공 요인:**
- **최소한의 인덱스**: 꼭 필요한 2개만 생성
- **정렬 최적화**: ORDER BY 절과 정확히 일치
- **단순함**: 복잡한 복합 인덱스 배제

### 3. 현재 최적 인덱스 상태
```sql
-- product 테이블 (기본 상태 유지)
SHOW INDEX FROM product;
+---------+------------+----------+--------------+-------------+-----------+-------------+
| Table   | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality |
+---------+------------+----------+--------------+-------------+-----------+-------------+
| product |          0 | PRIMARY  |            1 | id          | A         |   1,005,666 |
+---------+------------+----------+--------------+-------------+-----------+-------------+

-- product_sales_count 테이블 (성능 인덱스 추가)
SHOW INDEX FROM product_sales_count;
+---------------------+------------+-----------------------------+--------------+-------------+-----------+
| Table               | Non_unique | Key_name                    | Seq_in_index | Column_name | Collation |
+---------------------+------------+-----------------------------+--------------+-------------+-----------+
| product_sales_count |          0 | PRIMARY                     |            1 | id          | A         |
| product_sales_count |          0 | UKaymi30vdmuciumwi2cu8a7ay6 |            1 | product_id  | A         |
| product_sales_count |          1 | idx_sales_count_desc        |            1 | sales_count | D         |  ✅
+---------------------+------------+-----------------------------+--------------+-------------+-----------+

-- product_view_count 테이블 (성능 인덱스 추가)
+--------------------+------------+-----------------------------+--------------+-------------+-----------+
| Table              | Non_unique | Key_name                    | Seq_in_index | Column_name | Collation |
+--------------------+------------+-----------------------------+--------------+-------------+-----------+
| product_view_count |          0 | PRIMARY                     |            1 | id          | A         |
| product_view_count |          0 | UKm1bbep0j0cwh6w7h7blfc652j |            1 | product_id  | A         |
| product_view_count |          1 | idx_view_count_desc         |            1 | view_count  | D         |  ✅
+--------------------+------------+-----------------------------+--------------+-------------+-----------+
```

### 4. 인덱스 설계 원칙

#### ✅ 성공 포인트
1. **product 테이블**: 추가 인덱스 불필요 (PRIMARY KEY만으로 충분)
2. **정렬 전용 인덱스**: ORDER BY 절과 정확히 매칭
3. **DESC 정렬**: 내림차순 정렬에 최적화
4. **최소한의 인덱스**: 꼭 필요한 것만 생성

#### ❌ 피해야 할 실수
1. **product 테이블에 reg_dt 인덱스**: 불필요한 오버헤드
2. **복합 인덱스 남발**: 실제 성능 저하 유발
3. **JOIN 조건 인덱스**: 이미 UNIQUE KEY로 충분

---

## 🏆 결론

### 핵심 성과
- **20.3% 성능 향상**: 16.798초 → 13.382초
- **시행착오를 통한 학습**: 과도한 인덱스는 성능 악화
- **최적 인덱스 발견**: 단순한 DESC 인덱스 2개만으로 충분

### 교훈
1. **Less is More**: 인덱스는 많다고 좋은 것이 아님
2. **실제 테스트 중요성**: 이론과 실제는 다를 수 있음
3. **단계적 적용**: 한 번에 많은 변경보다는 점진적 최적화

### 추천 적용 순서
1. **1단계**: 핵심 DESC 인덱스 2개 생성 (20% 향상)
2. **2단계**: 캐시 테이블 또는 제한 조회 방식 (80% 향상 목표)
3. **3단계**: 인기상품 전용 서비스 분리

### 모니터링 포인트
- 쿼리 실행 시간 지속 측정
- 인덱스 사용률 확인 (`SHOW INDEX`)
- 메모리 사용량 모니터링
- 실행계획 변화 추적 (`EXPLAIN`)