# 🚀 인기 상품 조회 쿼리 성능 최적화 보고서

## 📋 테스트 환경

| 항목         | 내용                             |
|--------------|----------------------------------|
| DBMS         | MySQL 9.3.0                      |
| 데이터량     | 각 테이블별 5,000,000건          |
| 테스트 대상  | 인기 상품 TOP 5 조회 쿼리        |
| 주요 테이블  | `product`, `product_sales_count`, `product_view_count` |

---

## 📊 데이터 현황

```sql
SELECT 
  (SELECT COUNT(*) FROM product) AS product_count,
  (SELECT COUNT(*) FROM product_sales_count) AS sales_count,
  (SELECT COUNT(*) FROM product_view_count) AS view_count;
```

| product_count | sales_count | view_count |
|---------------|-------------|------------|
| 5,000,000     | 5,000,000   | 5,000,000  |

---

## 🔍 병목 쿼리 및 성능 분석

### A. 기존 쿼리 (LEFT JOIN + 정렬)

```sql
SELECT p.id, ps.sales_count, pv.view_count, p.reg_dt
FROM product p 
LEFT JOIN product_sales_count ps ON p.id = ps.product_id 
LEFT JOIN product_view_count pv ON p.id = pv.product_id 
ORDER BY ps.sales_count DESC, pv.view_count DESC, p.reg_dt DESC 
LIMIT 5;
```

- ⏱ **실행 시간**: 16.394초
- ❌ 정렬 대상이 전체 테이블로 정렬 비용 과다
- ❌ OUTER JOIN으로 인한 느슨한 조인

---

### B. INNER JOIN으로 단순 변경

```sql
SELECT p.id, ps.sales_count, pv.view_count, p.reg_dt
FROM product p 
INNER JOIN product_sales_count ps ON p.id = ps.product_id 
INNER JOIN product_view_count pv ON p.id = pv.product_id 
ORDER BY ps.sales_count DESC, pv.view_count DESC, p.reg_dt DESC 
LIMIT 5;
```

- ⏱ **실행 시간**: 13.183초
- ✅ OUTER JOIN 제거로 불필요한 row 제외
- ❌ 여전히 5,000,000건 정렬로 병목 유지

---

### C. 복합 인덱스만 적용한 기존 쿼리

```sql
CREATE INDEX idx_product_sales_optimized 
  ON product_sales_count (product_id, sales_count DESC);

CREATE INDEX idx_product_view_optimized 
  ON product_view_count (product_id, view_count DESC);
```

- 기존 쿼리 동일하게 사용
- ⏱ **실행 시간**: 13.034초
- ❌ 인덱스만 추가해도 성능 개선 효과는 미미
- 🔎 정렬 범위가 줄어들지 않기 때문

---

## ✅ 최적화 쿼리

```sql
SELECT p.id, ps.sales_count, pv.view_count, p.reg_dt
FROM (
    SELECT product_id, sales_count
    FROM product_sales_count
    ORDER BY sales_count DESC
    LIMIT 50
) ps
JOIN product p ON p.id = ps.product_id
JOIN product_view_count pv ON p.id = pv.product_id
ORDER BY ps.sales_count DESC, pv.view_count DESC, p.reg_dt DESC
LIMIT 5;
```

### 결과

- ⏱ 인덱스 전: 0.817초
- ✅ 인덱스 후: 0.008초

### 핵심 최적화 전략

| 전략                 | 설명                                  |
|----------------------|---------------------------------------|
| 서브쿼리로 정렬 범위 축소 | 5,000,000건 → 50건으로 축소             |
| 정렬 순서 단순화     | sales_count DESC → LIMIT 이후 JOIN |
| 인덱스 병렬 활용     | product_id, sales_count, view_count에 인덱스 사용 |

---

## 🔧 인덱스 구조

```sql
-- sales 정렬을 위한 복합 인덱스
CREATE INDEX idx_product_sales_optimized 
  ON product_sales_count (product_id, sales_count DESC);

-- view 정렬을 위한 복합 인덱스
CREATE INDEX idx_product_view_optimized 
  ON product_view_count (product_id, view_count DESC);

-- 등록일 정렬 인덱스
CREATE INDEX idx_product_reg_dt 
  ON product (reg_dt DESC);
```

---

## 📈 성능 비교 요약

| 버전                     | 실행 시간 | 정렬 대상   | 주요 특징                    |
|--------------------------|------------|-------------|------------------------------|
| A. LEFT JOIN             | 16.394초   | 5,000,000건 | OUTER JOIN + FULL 정렬       |
| B. INNER JOIN            | 13.183초   | 5,000,000건 | JOIN 조건 개선 불충분        |
| C. 복합 인덱스만 적용    | 13.034초   | 5,000,000건 | 인덱스만으론 의미 없음       |
| ✅ D. 최적화 쿼리 적용   | 0.008초    | 50건        | 정렬 범위 제한 + 인덱스 활용 |

---
