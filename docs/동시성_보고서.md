# 🚀 동시성 이슈 분석 및 해결 방안 보고서

## 1. 문제 식별: 왜 동시성 제어가 필요한가?

### 1.1. 경쟁 상태 (Race Condition)
여러 트랜잭션이 **공유 자원(Shared Resource)**에 동시에 접근하여 수정하려고 할 때, 접근 순서나 타이밍에 따라 결과가 달라져 **의도하지 않은 결과**를 초래하는 현상입니다. E-Commerce 플랫폼의 `상품 재고`, `사용자 잔액` 등은 대표적인 공유 자원입니다.

### 1.2. 상호 배제 (Mutual Exclusion)
이러한 경쟁 상태를 방지하기 위한 가장 기본적인 원칙은 **상호 배제**입니다. 특정 시점에는 단 하나의 트랜잭션만이 공유 자원에 접근하도록 제한하는 것입니다. 데이터베이스는 `잠금(Lock)` 메커니즘을 통해 상호 배제를 구현하고 데이터 무결성을 보장합니다.

본 보고서에서는 시스템 내에서 발생 가능한 주요 동시성 문제 시나리오를 식별하고, DB Lock을 활용한 해결 방안을 제시합니다.

### 🎯 분석 대상 시나리오
1.  **상품 재고 관리**: 여러 사용자가 동시에 마지막 남은 상품을 구매하는 경우 (분실 갱신, Lost Update)
2.  **사용자 포인트 잔액**: 한 사용자가 거의 동시에 포인트를 사용하고 충전하는 경우
3.  **선착순 쿠폰 발급**: 한정된 수량의 쿠폰을 여러 사용자가 동시에 발급받는 경우

---

## 2. 시나리오별 원인 분석

### 2.1. 상품 재고 (Race Condition)

-   **문제 상황**: `재고 확인`과 `재고 차감`이 원자적으로(Atomic) 실행되지 않아, 재고 이상으로 상품이 판매되는 상황 (Overselling)

-   **실패 시나리오 (재고 1개)**:
    1.  **사용자 A**가 재고를 조회합니다. (재고: 1개, 구매 가능)
    2.  **사용자 B**도 거의 동시에 재고를 조회합니다. (재고: 1개, 구매 가능)
    3.  **사용자 A**가 주문을 완료하고, 재고를 1 차감합니다. (재고: 0개)
    4.  **사용자 B**도 주문을 완료하고, 재고를 1 차감합니다. (재고: -1개)
    5.  **결과**: 재고가 없는 상품이 판매되는 심각한 데이터 불일치 발생.

    위 코드는 `SELECT` 후 `UPDATE`가 즉시 이루어지지 않고, 트랜잭션이 커밋될 때 반영됩니다. 이 간격 동안 다른 트랜잭션이 동일한 데이터를 조회하면 경쟁 상태가 발생합니다.

### 2.2. 사용자 잔액 및 선착순 쿠폰

-   **문제 상황**: 상품 재고와 동일한 `Read-Modify-Write` 패턴으로 인해 발생합니다.
    -   **사용자 잔액**: `현재 잔액 조회` -> `사용/충전 연산` -> `결과 업데이트` 과정에서 데이터 불일치 발생 가능.
    -   **선착순 쿠폰**: `쿠폰 재고 조회` -> `재고 유효성 검증` -> `재고 차감 및 사용자 쿠폰 발급` 과정에서 한정된 수량 이상으로 쿠폰이 발급될 수 있음.

---

## 3. 해결 방안: DB Lock 메커니즘

동시성 문제를 해결하기 위해 데이터베이스가 제공하는 잠금(Lock) 기능을 활용할 수 있습니다.

### 3.1. 비관적 잠금 (Pessimistic Lock)

-   **개념**: 데이터에 접근할 때부터 비관적으로 보고 "다른 트랜잭션이 동시에 수정할 것"이라 가정하여, 트랜잭션이 끝날 때까지 해당 데이터에 **배타적인 잠금(Exclusive Lock)**을 거는 방식입니다.
-   **동작 방식**: `SELECT ... FOR UPDATE` (X-Lock) 또는 `SELECT ... FOR SHARE` (S-Lock) SQL 구문을 사용하여 특정 레코드를 잠급니다. 잠금이 해제될 때까지 다른 트랜잭션은 해당 레코드에 접근/수정이 불가능하고 대기 상태가 됩니다.
-   **장점**:
    -   데이터 일관성을 확실하게 보장합니다.
    -   구현이 비교적 간단합니다.
-   **단점**:
    -   잠금으로 인한 병목 현상으로 전체적인 시스템 성능(throughput)이 저하될 수 있습니다.
    -   **교착 상태(Deadlock) 발생 가능성**: 둘 이상의 트랜잭션이 서로 상대방이 점유한 리소스를 기다리며 무한 대기하는 상태에 빠질 수 있습니다. 특히 여러 테이블에 Lock을 거는 경우, **Lock 획득 순서**를 동일하게 유지하는 것이 매우 중요합니다.

### 3.2. 낙관적 잠금 (Optimistic Lock)

-   **개념**: "충돌이 자주 발생하지 않을 것"이라고 낙관적으로 가정하고, 데이터를 수정할 때 **버전(Version)**을 확인하여 다른 트랜잭션에 의해 데이터가 변경되었는지 검사하는 방식입니다.
-   **동작 방식**: 테이블에 `version` 컬럼을 추가합니다.
    1.  데이터 조회 시 `version` 값도 함께 읽습니다.
    2.  데이터 업데이트 시, 조회했던 `version` 값과 현재 DB의 `version` 값이 일치하는지 확인합니다 (`UPDATE ... WHERE id = ? AND version = ?`).
    3.  `version`이 다르면 충돌로 간주하고 예외(`OptimisticLockException`)를 발생시킵니다.
-   **장점**:
    -   잠금을 직접 사용하지 않아 비관적 잠금보다 성능상 이점이 있습니다.
-   **단점**:
    -   충돌 발생 시, 애플리케이션 레벨에서 재시도(Retry) 로직을 직접 구현해야 합니다.
    -   충돌이 빈번하게 발생하면 재시도 비용이 커져 오히려 성능이 저하될 수 있습니다.
---

## 4. 시나리오별 최적 해결 방안 적용 및 검증

| 시나리오 | 추천 해결 방안 | 선정 이유 | 검증 방법 |
| :--- | :--- | :--- |:--- |
| **상품 재고 관리** | **Pessimistic Lock** | 재고는 돈과 직결되는 핵심 데이터이며, 특히 인기 상품의 경우 동시 요청이 빈번할 수 있습니다. 충돌 시 재시도 비용보다 데이터의 정합성을 보장하는 것이 더 중요하므로 비관적 잠금이 적합합니다. | **통합 테스트**: 100개의 스레드가 동시에 재고 1개씩 차감 시도. 최종 재고 0 확인. |
| **사용자 잔액** | **Pessimistic Lock** | 잔액 역시 돈과 관련된 데이터로, 결제 트랜잭션 내에서 데이터 정합성을 확실히 보장하기 위해 비관적 잠금을 사용하는 것이 안전합니다. | **통합 테스트**: 100개의 스레드가 동시에 일정 금액 차감 시도. 최종 잔액 일치 확인. |
| **선착순 쿠폰 발급**| **Pessimistic Lock** + **UNIQUE 제약조건** | 쿠폰 재고는 비관적 잠금으로 제어하여 동시 발급을 막고, `user_coupon` 테이블에 `(user_id, coupon_id)`로 UNIQUE 제약조건을 추가하여 중복 발급을 DB 레벨에서 원천 차단하는 이중 안전장치를 마련합니다. | **통합 테스트**: 150개 스레드가 100개 한정 쿠폰 동시 발급 시도. 최종 발급 수 100 확인. |

